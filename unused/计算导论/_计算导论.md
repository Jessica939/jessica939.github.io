
# 计算导论
## **基本类型**
### **整数、浮点数、复数、字符串、逻辑真值的表示**
#### **整数 integer**
* 默认十进制
* Binary(二进制): `0b` (0B) 96 = 0b1100000 or 0B1100000
* Octal(八进制): `0o` (0O) 96 = 0o140 or 0O140
* Hexadecimal(16 进制): `0x` (0X) 96 = 0x60 or 0X60.
    * 10,11,…,15 are ‘ABCDEF’ or ‘abcdef’
    * 8 = 0x8, 9 = 0x9, 10= 0xA or 0xa, …, 15 = 0xF or 0xf.
* 下划线来提高可读性 (Python 3.6)
    * 123,456,789 可以使用 123_456_789 来表示
    * 0xFFF_FFF_FAA, 123.456_789
* 完整存储，没有位数限制
#### **浮点数 float**
* 近似保存，浮点数不准确，精度有限制
* 范围 2.2250738585072014e-308 到 1.7976931348623157e+308
* 舍入误差 Rounding error
    * `print(123.00)`：123.0
    * `print(1e4)`: 10000.0
    * `print(.1)`: 0.1
    * `print(.1+.1+.1)`：0.3000000000000004
    * `x = 13.949999999999999999 print(x)`: 13.95
#### **复数 complex number**
  * `a+bj`，b=1 时 1 不能忽略
  * `print(1+2j)`: (1+2j)
  * 使用 `z.real`, `z.imag` 访问 z 的实部和虚部，但不能修改因为 immutable
  * `complex(real, imag)` 构造虚数，参数均可选，默认值为 0
    * `z2 = complex(3, 4)` `print(z2)` 输出 (3+4j)
#### **科学计数法**
  * `aeb` : a × 10^b
  * `1e3=10^3`
  * `1e+3=10^+3`
  * `1.2e-5=1.2*10^-5`
  * e 的前后不能加空格
#### **逻辑真值**
  * True is 1, False is 0. 大小写敏感，`True*12=12`
  * **False：** [], (), {}, False, 0, None
  * **True：** 非零数字和非空字符串
  * 逻辑操作符 `not` `and` `or` 优先级：非 > 和 > 或
#### **逻辑表达式**
  * x 被翻译为 bool（x）
  * bool 是一种特殊形式的 int
      * `print（None == False）`：Flase
      * `print（type（True））：class ‘bool’`
  * 可能不直接返回 True 和 False，而是返回相等的值
      * `1+2+3>6 or 3`, return 3, `bool(3)==True`
      * `0 and “abc”>”ABC”`, return 0, `bool(0) ==False`
  * **短路求值 Short-circuit evaluation**
      * `True or x`, `False and y` 中 x 和 y 不会被判断
      * `x < y <= z` 等于 `x < y and y <= z`，不过前者 y 只计算一次，如果 x<y 为 False，z 不会被计算

### **基本类型转换函数：** `int()`, `float()`, `str()`, `bool()`, `bin()`
  #### **int()**
      * 浮点数，字符串到整数，直接截断浮点数的小数部分，只能转换整数字符串
      * `int()` 不一定总是下取整，例如 `int(4.9999999999999999) = 5`
      * `print(int("3.14"))`: ValueError
      * `print(int(float("3.14")))` 可以，返回 3
  #### **float()**
      * 字符串，整数到浮点数
  #### **bin()**
      * `a=bin(10)` 输出 `0b1010`
          * 去掉 0b 用 string 的 slicing 就行了
      * 转换为二进制。
      * `x.bit_length()` 计算二进制值长度
      * `x.bit_count()` 计算 1 的个数
### **算术运算符：** `+`, `-`, `*`, `/`, `//`, `%`, `**`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`
* 和数学中一样，运算符有优先级，`**` 高于 `*`，`/`；`*`, `/` 高于 `+`，`-` 括号()可以改变运算顺序
* `**` 中不能加空格
* **除法/：** 运算结果为 float
* **整除//：** a, b 都为 int，结果为 int; a, b 有一个为 float，结果为 float
* **余数%**
    * 判断两个数同余，不能用 `a == v`, 要用 `(a-b)%n == 0`
    * 在计算大整数的余数的时候，用同余运算来处理，计算量更小
* 常见错误：`x^0.5` 写成 `x ** 1/2`
* 连等及 `+=`，同时赋值都采用之前的值，不会在计算中改变
### **逻辑运算符：** `and`, `or`, `not`, `is`, `in`, `==`, `!=`, `<=`, `>=`, `<`, `>`
  * `>`, `<`, `==`, `>=`, `<=`, `!=`, `in`, `not in`, `is`, `is not` 优先级相同
  * `is` 判断 id 相同吗，`==` 判断值相同吗
  * `5.0==5`, `4.9999999999999999999=5`

### **位运算：** `|`, `&`, `^`, `>>`, `<<` (取反操作~x 不考)
* `>>` 右移运算符将一个数的所有位向右移动指定的位数，左侧的空位填充 0。等价于除以二的 n 次方
    * `8 >> 1` 将二进制数 1000 向右移动 1 位，得到 0100，等于十进制数 4。
* `<<` 左移运算符将一个数的所有位向左移动指定的位数，右侧的空位填充 0。等价于乘以二的 n 次方
* 位运算符优先级比算术运算符低（`3 + 4 << 1` 等价于 `(3 + 4) << 1`）
* `n&1` 判断是不是偶数，因为比较的是一个二进制 00001，前面一定全都是 0，比较最后一个。
* `n>>1` 相当于除以二
### **range 的写法**
* `range(a,b,d)`: (从 a 到 b 以 d 为公差的等差数列， **不包括 b**) d 默认为 1，可以省略。a, b, d 必须都为整数
* `x = range(100)`，type(x)为 `<class 'range'>`
## **变元与赋值语句**
### **变元**
* 数字，字母，下划线，用字母或者下划线开头，文件名也是
* 大小写敏感，惯例不使用大写字母
* 有 35 个关键字：`['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']`
* 变量 type 由 python 决定
### **指向关系**
### **重新赋值** (a = …)
    * 改变 a 的地址
    * 同时赋值 `<var>, <var>, ..., <var> = <expr>, <expr>, ..., <expr>`
### **修改赋值** (a[i] = …, a.x = …, …)
### **immutable vs. mutable**
* `+=` 的区别 `a = a+b` 重新赋值，`a+=b` 对于 mutable 对象是修改
* mutable 对象不复用之前已有具有相同内容的对象
### 注：
* 赋值语句中的表达式如果是单个变元 a，那么直接返回 a 指向的对象而不作 copy。
* 赋值语句表达式中的每一次运算原则上都会创建新的对象。immutable 对象有可能会共享之前创建的对象。
## **条件分支**
* `==` 判断两个对象的内容是否相等，`is` 判断两个对象是否是同一个（即是否在同一个地址）。
* “a” or False 返回什么值之类的不考。
* **基本语法:** `if`, `elif`, `else`, `match`
    * 如果用多个 if 而没有用 elif，那么 else 只判断最后一个 if 的 else
    * if 语句中至少有一行语句，可以用 `pass` 跳过
* **a if b else c 形式**
    * `return a if b else c` 等价于 `if b: return a else: return c`
* 条件不为逻辑表达式的判定（例如 `if “a”`: 等等）
## **循环**
### **for 循环**
* for 循环的集合可以是 list, dict, tuple, set, str, range, etc.（iterable）
* 在 `for x in xxx: do_sth()` 中 `do_sth()` 对 x 的修改并不改变 x 的遍历顺序
    * 用 `while` 手工操作
    * 用集合 `collection_a.copy()` 来处理
    * 用 `for x in reversed(lst)`:
    * 列表推导
* 会无限循环
### **while 循环**
* `while x:` #bool(x)==True
### **for … else 循环**
### **while … else 循环**
* 当循环正常结束的时候，也既没有被 break，运行 else 语句
* 如果没有 break 语句，else 会永远执行
### **break 和 continue**
* `break`: 跳出当前循环
* `continue`: 跳出当次循环迭代，继续循环
### **for 循环中使用 list, dict，set 的注意点**
    * dict 在循环中修改大小，会报错。
    * 如果 list, dict 在循环中不改变大小，也就是说只改变值是可以的，可以直接修改 index 以及 key 上的 value
    * 如果需要修改容器的大小，一般用 `.copy()` 在副本上遍历，或者改用 while 循环。
## **函数**
### **语法以及调用方式**~
* `def function_name(param1, param2, …. ): return ……`
* 一个函数调用由 函数名+参数 决定，参数不同、函数名相同也是不同的调用
* 被调用后才会运行，运行后函数内部的代码和数据被清除，是一次性的（销毁变元不一定销毁他们指向的对象）
### **参数类型：** positional, keyword, arbitrary positional, arbitrary keyword
* 参数数量要一致，对齐，参数传递赋值语句 x1,x2,x3=y1,y2,y3
* 函数调用时候输入的参数实际上是输入对象的地址
* default arguments 默认参数
* **positional 位置参数**
* **keyword 关键字参数**
* **arbitrary positional 任意位置参数**
* `*args` 输入参数，作为元组传递
* **arbitrary keyword 任意关键字参数**
* `**kwargs` 接受关键词参数，作为字典传递，kwargs 等不是关键词，是惯例，可以修改
* **特定位置参数**
* **规则**~
* 默认参数在非默认参数之后
* 关键字参数在位置参数之后
### **缺省参数以及摆放位置的限制**
* 缺省参数必须出现在所有位置参数之后
* 要按顺序摆放，或者通过 keyword 传递
* 小心可变对象作为缺省参数的默认值，可以将其设为 None 来避免
### **return**
* return 立即终止函数执行，如果没有执行 return 语句则返回 None
* None 与“”，0 False 都不一样，是 NoneType
* 多个返回值是 tuple 形式
### **局部变量和全局变量互不干涉**
* **global** 如果要在函数内修改函数外部某个变量，可以在前面加 global 关键字
* 可以在函数内部直接使用外部的变量，如果不修改这个变量（如果重新赋值 `a=2` 不报错，如果 `a+=1` 报错）
* 函数内部和外部变元可以有有限度的重叠，只要不在函数内部又用外部变元又把它当成内部变元就行（上面不行下面可以）
### **传入的对象实质是对象的地址**
* 重新赋值不影响外部对象
* 对象函数调用、修改赋值或者对象成员修改会影响外部对象的内容（如果传入参数是 mutable 的话）
### **类型提示**
### **decorator**
* 函数定义内部也可以嵌套定义函数，也可以返回内部嵌套定义的函数。
### **递归机制**
* 一个终止状态：简单情况直接计算
* 一个化简状态：复杂情况转化为简单的情况
* **stack：**
    * push 堆叠起来，A1,A2,...An 被 push 到 stack 里
    * pop 一个个 remove，执行 An，pop up An-1,...,A1
    * 整个过程叫 stack（FIFO：First in last out）
### **对象函数调用语法（例如 lst.count()）**
### **基本的 lambda 语法**
* lambda 表达式（也称为匿名函数）是在 Python 中创建小型匿名函数的一种方式
* **lambda 参数列表 : 表达式**
* lambda：关键字，表示这是一个匿名函数。
* 参数列表：用逗号分隔的参数列表，类似于常规函数的参数。
* 表达式：单个表达式，匿名函数计算并返回其值。
* `square = lambda x: x**2`
* `print(square(5))` # 输出: 25
* `add = lambda x, y: x + y`
* `print(add(3, 5))` # 输出: 8
### **晚绑定 late binding**
* 函数中使用的外部变量由调用的时候的值决定，而不是定义时的值决定
* `funcs = [lambda x: x + i for i in range(5)]`
* `print([f(10) for f in funcs])` # 输出: [14, 14, 14, 14, 14]
* 在这个例子中，所有的 lambda 函数捕获了 i 的最终值（4）。这是因为在 lambda 函数定义时，i 的值并没有被确定，而是在 lambda 函数实际调用时才确定。这也体现了晚绑定的概念。
### 其它
* 缩进推荐使用空格，不能和 tab 混用
* 后面的函数会覆盖前面的函数
## **内置函数**
### **print(str, end, sep)**
* end 表示结尾符，默认是回车
* sep 表示分隔符，默认是空格
* `print()` 表示单空一行，因为默认 `end="\n"`
* `print(123),print('123')` 效果一样
* `print(str1,str2,...,strn,end="SDDW\n",sep="aa")`
### **eval()**
* 注意 eval 可以处理很广泛的表达式，例如 `eval("[1,2,3]")` 返回列表 `[1,2,3]`
* `x=eval("1+2+3")` `print(x)`: 6
* eval 把一个 string 翻译为一个 python 表达式并计算他的值
* eval 可以将一个字符串形式的 list，转换为 list：`lst = eval(“[1,2,3,[1,2,3]]”)`
* `program = input('Enter a program:')` `eval(program)` #用户输入 `[print(item) for item in [1, 2, 3]]`，那么输出 1,2,3
* eval 只适用于表达式，不适用于赋值语句 Error: `eval(“a=1”)`
### **exec()**
* 执行创造的程序。返回 None。
* `exec("ax=-1.234")` `exec("print(ax)")` 输出 -1.234
### **type()**
* 返回类型
### **id()**
* 返回地址
### **input()**
* 返回一个字符串！
* 回车键（\n）终止输入
* `<variable> = input(<prompt>)`
* input 一次输入多个对象
    * `x,y,z = tuple(input().split(','))`
    * `x,y,z = float(x), float(y), float(z)`
### **len()**
* 返回容器里面元素的多少
### **sum()**
* 计算可迭代对象所有元素的总和，元素必须是数字类型（整数、浮点数、复数）
* `sum(iterable, start)`
    * iterable：这是一个包含数字的可迭代对象（如列表、元组等）。
    * start（可选）：这是一个指定的初始值，默认值为 0。计算总和时，它会被加到可迭代对象的元素之和中。
* 如果可迭代对象为空，且未指定 start 参数，sum() 返回 0。
### **map()**
* map() 函数会将一个函数应用于可迭代对象（如列表、元组等）中的每个元素，返回一个新的迭代器。`map(function, iterable)`
* `squared_numbers = map(square, numbers)`
### **filter()**
* filter() 函数会将一个函数应用于可迭代对象中的每个元素，并根据函数的返回值（True 或 False）过滤元素，返回一个新的迭代器。`filter(function, iterable)`，True 返回，False 不要
* `even_numbers = filter(is_even, numbers)`
### **reduce()**
* reduce() 是 Python 的 functools 模块中的一个函数，用于对可迭代对象中的元素进行累积计算。它可以应用一个函数（通常是二元函数）于可迭代对象的前两个元素，然后将结果与下一个元素继续进行计算，直到处理完所有元素并返回最终结果。
* `from functools import reduce`
* `reduce(function, iterable[, initializer])`
* function：一个二元函数，用于将可迭代对象中的两个元素进行计算，并返回一个结果。
* iterable：一个可迭代对象，如列表、元组等。
* initializer（可选）：一个初始值，将作为计算的第一个参数与可迭代对象的第一个元素进行计算。
* `total = reduce(lambda x, y: x + y, numbers)`
### **isinstance()**
* `x = isinstance(object, class)` 如果是这个类返回 True，不是返回 False
* class：类或或者包含类的元组。
### **issubclass()**
* `x = issubclass(class, classinfo)` 如果 class 是 classinfo 的子类（或是其子类之一），则返回 True。否则，返回 False
* classinfo：可以是单个类或包含多个类的元组。
### **reversed()**
* `reversed(seq)` 反向遍历序列，返回反向迭代器
    * `reversed_list = list(reversed(my_list))`
* **zip()**
    * 将 n 个 list(tuple, str 等等)按元素合并为一个新 list: **每个元素都是 n 维的**
* 变元类型如果和基本函数相同，那么声明出来的变元就会覆盖原来函数，那么原来函数就不能用了
* **List (Mutable)**
    * **列表的表示**
    * **构造函数 list()**
        * `list("str")`
        * `list(range(a,b,n))`
        * `list()` 创造空集合
    * **加法与乘法**
        * `a+b` 聚合两个列表
            * `list1 = [1, 2, 3]`
            * `list2 = [4, 5, 6]`
            * `result = list1 + list2`
            * `print(result)` # 输出: [1, 2, 3, 4, 5, 6]
        * `a*n` 将一个列表重复 n 次

## Page 12: List 的索引、切片与基本方法

* `list1 = [1, 2, 3]`
* `result = list1 * 3`
* `print(result)` # 输出: [1, 2, 3, 1, 2, 3, 1, 2, 3]
* **index 访问与修改** （`a[index] = …`, `b = a[index]`, …）
    * `a[i]` 超出长度会有 error
    * 负值是倒数
    * list 的修改不改变 list 的 id，只改变内部元素的 id
* **slicing 访问与修改** （`a[start:stop:step] = …`，`b = a[start:stop:step]`）
    * step 可以为负数，`a[::-1]` 返回 a 的逆，step=1 时可以忽略
    * 修改前后的类型应该一致 `[]=[]`
    * 可以通过修改为空列表删除列表元素 `a[2,4]=[]`
    * 可以通过将空列表修改为列表增加元素 `a[2,2]=[1,2,3]`
    * `id(a[:])` 与 `id(a)` 不同
    * slice 可以越界，超过范围自动处理报错，非法写法直接返回空列表
        * `a = [1,2,3,4]`, `a[3,-4,1]=[]`, `a[:10]=[1,2,3,4]`
    * list[::]可以，但是 dict 和 set 不可以，没有切片操作因为无序
* **slicing 缺省值** （`a[:]`，`a[1:]`, `a[:stop]`，`a[::-1]`）
* **in**
    * in 在列表中返回 True
    * not in 在列表中返回 Flase
* **.insert(), .index(), .remove(), .append(), .sort(), .extend(), .count(), .clear()**
    * **list.insert(i,x)**
        * 在 i 个位置插入 x 的值，返回 None，如果值超过列表长度在最后面增加元素
    * **list.append(x)**
        * 在最后增加值直接修改原列表，返回 None
        * `a.append(a)` -> `True, True` (递归引用)
    * **list.extend()**
        * 把 interable（list，tuple，string，etc）的所有元素加到 list 的末尾，返回 None

## Page 13: List 更多方法与操作

* 不能直接 extend dict，可以 `extend dict.values()`
* **list.sort()**
    * 直接修改原列表，返回 None，从大到小排序，元素必须是同种类型
    * 参数 `reverse=True` 让函数降序排列，默认 False
    * 注意，和 sorted 不同，sorted 是一个函数 `b=sorted(a)`，创建一个新对象而不是修改，用于任何可迭代对象
* **list.index(x, start, end)**
    * 返回第一个值为 x 的序号，start，end 进行 slice，编号依然是原列表的序号，如果没有 x 的值 error
* **list.count(x)**
    * 返回 list 中 x 的个数，没有其它参数
* **list.clear()**
    * 清除所有元素，返回 None
* **list.pop(index=-1)**
    * 默认删除最后一个元素，并获取它的值
* **list.remove(value)**
    * 删除第一个是这个值的元素，返回 None
* **list.reverse()**
    * 倒转 list，返回 None
* **del lst[index], del lst[start:stop:step]**
    * `del a[1:4]` 通过 index 或者 slice 删除元素
    * `del a[2], a[3]` 表示 `del a[2]` `del a[3]`，顺序执行故删除的是下标 2 和 4 的元素
    * 尽可能不要循环动态删除一个数据结构，可能出 bug
        * 列表在内存中是顺序排列的，删除后要重新恢复速度慢
        * 标记为不存在的元素例如-1 或者 None
        * 或者用一个新的列表保存结果
* **enumerate()**
    * `lst = ['a', 'b', 'c', 'd']`
    * `for offset, item in enumerate(lst):`
    * `print(f"Index: {offset}, Value: {item}")`

## Page 14: 列表推导式与拷贝

* **(nested) list comprehension 列表推导式**
    * `squares = [x**2 for x in range(10)]`
    * **单重循环** `[expression for target in iterable if conditon]`
    * **多重循环** `[expression for target1 in iterable1 if condition1 for target2 in iterable2 if condition2 .. for targetN in iterableN if conditionN]`
* **创建新的 list**
    * for
    * `[0]*n`
    * `list(range())`, `list(set)`, `list(str)`
    * list comprehension 清晰可读正确，更快
* **有 deepcopy 的用处**
    * `list = [[1]] * 3` 是浅拷贝
    * `list = [[1] for _ in range(3)]` 相当于对 `[1]` 作了 deepcopy
* **shallow copy & deep copy**
    * `.copy()` 会改变第一层的地址，若 `b=a` 则不改变地址，copy 后 list 的 id 改变，其中元素的 id 不变
    * 如果没有嵌套列表的话没事
    * `copy.deepcopy()` 会把嵌套列表所有的地址改变，除了最后一个没有嵌套列表的数据地址不改变
    * `*n` 操作不作 deepcopy，地址相同
* **slicing 类似于 shallow copy (不拷贝里面的对象)**
* `b = list(a)`，`b = a[:]`，`b = a.copy()`，是 shallow copy。

## Page 15: List 推导式细节与 Tuple

* 列表推导式在每次迭代时都会重新计算推导式中的表达式。 例如 `[[1] for _ in range(3)]` 相当于对 `[1]` 作了 deepcopy。
* `lst = lst + lst1` 和 `lst += lst1` 前者改变地址重新赋值后者不改变地址
* 系统为了节约空间，有时候会共用不可修改对象，可修改对象一定不会共用
* list 中的元素可以是不同类型的
* **Tuple (Immutable)**
    * immutable counterpart of list 元组是不可变列表
    * **tuple 表示方法**
        * （）可以被省略 `tup = 1, 2, 3`
        * 创造单元素 tuple: `tup=(1,)` 或者 `1,` 否则 `(1)` 是 int
        * `print(type(([1,2,3])))`：`print(type(([1,2,3])))`
        * `print(type(([1,2,3],)))`：`<class 'tuple'>`
    * **构造函数 tuple()**
        * 从列表，字符串，字典（key），元组创建元组

## Page 16: Tuple 操作与 Dict 基础

* 可以通过 `a=()` 创建空 tuple，`[1,]` 是表示 `[1]` 不是 `[(1,)]`
* tuple 里面有列表，里面的列表是可以修改的，也就是说 tuple 里面的元素可以是 mutable 的
* tuple 中 `+` 会创建一个新列表 `tup+=(2,3)`，而 list 会修改原来列表 `lst+=[4]`
* 可以嵌套 `((a, b), c) = ((1, 2), 3)`
* 同时赋值 `x1, x2, x3, x4 = a, b, c, d`
* 函数中同时 return 多个值用的是 tuple
* 可以使用 `a=b=c=1` 赋值，但不推荐
* **index 访问**
    * tuple[index]
* **slicing**
    * tuple[start:stop:step]
* **in**
    * 使用 in 关键字来检查某个值是否存在于元组中
* **.index(x)**
    * 返回 x 的位置，如果不存在发生 error
* **.count(x)**
    * 返回 x 的出现个数
* **加法，乘法**
    * `+` 将两个元组合并成一个新的元组
    * `*` 将元组中的元素重复指定次数，生成一个新的元组。
* Python 里面没有 tuple comprehension。
* **Dict (Mutable)**
    * **Dict 的表示**
        * 字典使用花括号 `{}` 表示，其中的键值对用冒号 `:` 分隔，键值对之间用逗号 `,` 分隔。
    * **Dict 的构造方法（包括 dict.fromkeys()）**
        * `dict()`
        * **关键字参数创建** `dict(**kwarg)`
            * `d1 = dict(a=1, b=2, c=3)`
        * **映射创建** `dict(mapping, **kwarg)`：
            * `d2=dict({'a': 1, 'b': 2, 'c': 3})`
            * `d3=dict({'a': 1, 'b': 2}, c=3, d=4)`
        * **可迭代对象创建** `dict(iterable, **kwarg)`
            * `d4 = dict([('a', 1), ('b', 2), ('c', 3)])`

## Page 17: Dict 创建与核心操作

* `d5 = dict([('a', 1), ('b', 2)], c=3, d=4)`
* `dt = dict({})`
* **zip 创建**
    * `my_dict = dict(zip("xyz", [1, 2, 3]))` 输出: `{'x': 1, 'y': 2, 'z': 3}`
* **dict.fromkeys()**
    * `dict.fromkeys(iterable, value=None)`
    * iterable: 一个包含键的可迭代对象。
    * value: 每个键的初始值（默认为 None）
    * `keys = ['a', 'b', 'c']`
    * `newdict = dict.fromkeys(keys, 0)`
    * `print(newdict)` # 输出: `{'a': 0, 'b': 0, 'c': 0}`
* Dict 的 key 必须 **hashable**（mutable 的 list 和 set 不能作为 key，大部分 immutable 的对象是 hashable 的，tuple 如果里面有 list 那就不 hashable）
* **通过 key 进行访问、修改与增加(dt[key])**
    * 如果 `dict[x]`，x 不是 key，会 error，不能通过 index 访问字典. 3.6+版本后有顺序
    * 通过 key 重新赋值或者增加元素
* in 和 not in 判断是不是在字典里
* **.keys(), .values(), .items()**
    * `dict.keys()` 返回 `dict_keys(['test', 1.2, 3, 5])` ，type 是 `<class 'dict_keys'>`，要自己转成 list：`list(a.keys())`
    * `dict.values()` 返回 `dict_values`
    * `dict.items()` 返回 `dict_items`
* **{**a, **b}, a | b, a.update(b)**
    * `{**a, **b}` 融合两个 dict，key 相同以后面的值为准
* **a.update(b)** 返回 None，相同的 key 用 b 中的值更新 a 中的值
* **a|b** 合并两个 dict，b 的值取代 a 的值，与 `**` 相同
* **get()和 setdefault()**
    * `get(a,b)` 获取 a 的值并返回，如果没有 a，返回 b 设定的 default value，b 默认为 None

## Page 18: Dict 高级操作与循环

* `setdefault(a,b)` 获取 a 的值并返回，如果不存在，返回 b 设定的 default value，并且在 dict 里面增加 a：b
* **删除元素**
    * `del dict[key]`: 通过 key 删除元素，也可以删除整个字典
    * `dict.clear()`: 创建一个空字典
    * `dict.pop()`: 通过 key 删除元素，返回 value，至少需要一个参数
    * `dict.popitem()`: 删除最后一个 item，返回最后一个键值对
* **多行表达式**
    * **显式：** 使用 `\` 去把 statement 划分成多行，`\` 后面不能有空格
    * **隐式：** 使用 `(), [], {}`
* **loop**
    * **打印 key**
        * `for x in dict: print(x)`
    * **打印 value**
        * `for x in dict: print(dict[x])`
        * `for x in dict.values(): print(x)`
    * **打印 item**
        * `for x in dict.items(): print(x, y)`
* 在迭代过程中增加或者删除字典元素是语法错误，可以使用 `dict.copy()`
* **dict comprehension**
    * `dt = {x:x for x in range(10)}`
* **构造函数是 shallow copy**
    * `dict.copy()` 会改变地址
* dict 的 key 不可以重复，value 可以重复
* value 可以是一个函数，当然 key 也可以是函数只要不可变
* **一些用法**

## Page 19: Set 与 String

* **Set (Mutable)**
* **Set 表示方法**
    * 无 index
* **Set 构造函数**
    * `{}` 创造一个空字典而不是空集，`set()` 可以创造空集
    * `set()` 参数为 List, tuple: all the elements；Dict: all the keywords；String: all the character
    * 只能输入一个参数，`set(1,2,3)` 不行
* Set 里面的元素必须 hashable，`([2,])` 不行
    * set 对象里面的对象必须也是 hashable 的
* **in**
* **集合运算：a | b, a & b, a ^ b，a-b**
    * `a | b` 并集
    * `a & b` 交集
    * `a ^ b` 对称差
    * `a-b` 差集
* **.add(), .remove()**
    * `a.add(6)`, 返回 None
    * `a.remove(6)` 返回 None，若没有则引发异常，而 `a.discard(6)` 不会
* **<=, <, >, >=**
    * `A<=B`: 返回 True 如果 A 是 B 的子集
    * `A<B`：返回 True 如果 A 是 B 的真子集
* **set comprehension**
    * `st = {x**2 for x in range(10) if x < 5}`
* **构造函数是 shallow copy**
* **List, Dict, Set, Tuple 在不打破 Dict/Set 里面的 key 必须 hashable 的情况下可以任意嵌套。**
* **List, Set,Tuple 的构造函数接受任意 Iterable 对象，其中 Dict 默认的是.keys()。**
* **内置的构造函数一定会返回一个新对象。**
* **String (Immutable)**
* **创建**

## Page 20: String 操作与方法

* `“…”` 和 `’…’`, 和 `“““…”””` 和 `.str()`
* 单双引号相同，但不可混用，与最近的匹配
* **index 访问**
    * `str[i]`
* **slicing**
    * `str[start:stop:step]`
* **加法和乘法**
    * `str1+str2` 返回他们的合并
    * `str*n` 重复 n 次 str，如果 n 小于等于 0 返回空字符串
* **.find(), .split(), .join(), .replace(), .index(), .count(), .upper(), .lower()**
* **split(seperator)**
    * seperator 可选，如果没有参数，会依照所有空格、换行、tab 进行分割，其中如果有连续的空格、换行、tab 会合并在一起作为分隔符。`s.split(" ")` 只会以空格作为分隔符，并且连续的空格会分隔出空字符串（即连续空格之间认为是空字符串）。
* **str.join(list)**
    * 连接一个 list，tuple，set 或者 dict 的 key，或者字符串，也即所有 iterable 的对象
    * `result = "-".join(text)`
* **str.find(sub, start, end)**
    * 返回第一个 sub 在切片中的位置，start 和 end 可选，如果没找到返回-1
* **str.count(sub, start, end)**
    * 返回 sub 在切片中的个数
* **str.isdigit()**
    * 如果 str 里全是数字并且至少有一个字符，返回 True，否则 False
* **str.upper(a), str.lower()**
    * 返回 a 的 copy，全大写或全小写
* **str.strip()**
    * 去除 str 两端的所有空白字符
* **str.rstrip(), str.lstrip():**

好的，这是根据 PDF 第 21 页至第 46 页内容整理的 Markdown 笔记。

## String 方法补充与转义字符

* 去除右边/左边所有空白字符（包括空格、制表符、换行符等）
    * `str.rstrip()`: 去除右边
    * `str.lstrip()`: 去除左边
* `str.replace(old, new, count)`
    * 返回 str 的 copy，把 old 替换为 new，次数为 count，count 默认为所有
    * 可以直接在字符串上调用方法例如 `print("hello".upper())`
* **转义字符 format string**
    * `\n`: 换行 newline
    * `\t`: tab，`str.expandtabs(n)` 把 tabsize 改编为 n
    * `\\`: `\`
    * `\a`: 铃声（控制台）
    * `\r`: 回到当前行的开始（首字符）
        * `print("This is a great world.\r Welcome here.")`: Welcome here.t world
    * `\b`: 光标回退一位
    * `\f`: 光标换到下一行的相同位置
    * `print("\"")`: `"`
    * 在字符串前加 r 取消转义字符 `r"..."`
    * 如果写 `print("\ ")`，那么 python 会识别为 `\\` 并且不会报错，但会报一个警告 (syntaxwarning)。

## 三种格式化输出方式

* `"... %s... %d" % (a, b)` 和 `“{}. ..{}”.format(x, y)` 和 `f“{x}…{y}”` 前后中间没有空格
* `“...%d...%d...” %(age, distance)` (注：来源于 C 语言)
    * `%s` (字符串), `%d`(整数), `%f`(浮点数)
* `“...{}...{}...”.format(age, distance)` (注：python 所特有，更安全)
    * `{}` 占位符，系统根据输入的数据自动推导其类型
    * **使用关键字参数的字符串格式化**
        * `formatted_string = "这是一段包含占位符的字符串：{a}, 以及另一个占位符：{b}".format(a="苹果", b="橙子")`
    * **使用位置参数的字符串格式化**
        * `formatted_string = "这是第二个值：{1}, 这是第一个值：{0}".format("苹果", "橙子")`
        * `print(formatted_string)`：这是第二个值：橙子，这是第一个值：苹果
    * 混合使用关键字参数和位置参数，位置参数要放在关键字参数前面
    * **不使用参数**
        * `“...{}...{}...”.format(age, distance)`
    * `format()` 是 string 类自带的一个函数 (`{}` 中间没有空格)
    <div v-pre>
    * 要打出 `{}` 使用 `{{}}`
    </div>
    * 转换为二进制，box 分别为 2,8,16 进制
        * `x1 = int(str1)`
        * `x2 = int(str1, base=2)`
        * `str1 = "{:b}".format(x1)`
        * `str2 = "{:x}".format(x1)`

## f-string 与格式化细节

* **f-string: f"{age}...{distance}"**
    * 大写 F 也可以
    * `print(f"The value of pi is approximately {math.pi:.3f}.")`
<div v-pre>
    * `print(f"{{{70+4}}}")`: `{74}`
    * `print(f"{{{{70+4}}}}")`: `{{70+4}}`
</div>
* **string 格式 {:format}**
    * Alignment(对齐方式: `<`, `=`, `>`), width(宽度), 小数位
    * 每个单元格，有宽度。所谓宽度(width)为 10，就是输出的时候，用当前光标位置后面 10 个位置来输出数据。有三种情况：
        * 数据长度大于 10。默认输出原数据
        * 小于 10。左对齐`<` 和右对齐`>` 和居中对齐`^`（默认右对齐）
        * 等于 10。正常输出即可
    * 对于浮点数，要进一步指明小数点后面的位数。`10.3f` 就是宽度为 10，后面保留 3 位, `f` 表示浮点数
* **f: 浮点数 d: 10 进制整数**
    * `print("The lengths are {:>10.3f}, {:<10.3f}, {:^10.3f}.".format(10.1, 8.5, 6.9))`
    * `{:.2f}`
* **c: 字符**
    * `print("The ASCII/unicode character is {:c}".format(65))` 输出 The ASCII/unicode character is A
* **s: 字符串**
    * `print("The length is {:12s}".format("Hello"))` 输出 The length is Hello
* **格式化符号补充**
    * `<`: 左对齐
    * `>`: 右对齐
    * `^`: 居中对齐
    * `=`: 符号放在最左侧
    * `+`: 正数加正号
    * `-`: 负数加负号
    * Space: 正数加空格
    * `,`: 千位分隔符
    * `_`: 下划线作为千位分隔符
    * `b`: 二进制
    * `c`: unicode 字符
    * `d`: 十进制
    * `e/E`: 科学计数法
    * `f/F`: 定点数格式
    * `g/G`: 通用格式
    * `o`: 八进制
    * `x/X`: 十六进制
    * `%`: 百分比格式

## 字符串操作补充与 Class 基础

* **字典序**
    * `>=<`：字典序 `ax>abx` 逐个比较，如果到了一个字符最后一个位置，另一个字符还有，那短的字符小
* **加法乘法**
    * `str1 +str2`, `str1*n`, `str1+=str2`
* **三引号："""…"""**
    * 多行（也就是输入的时候有换行），会自动换行，加 `\` 取消换行
    * 在 Python 中，文档字符串（docstring）是一种字符串文字，它出现在模块、函数、类或方法定义中的第一个语句处。成为文档的特殊属性 `__doc__`。
* 控制台中输入东西自动有输出，而 IDE 必须要 print
* **Class**
    * **基本语法** (`class …: …`)
    * **属性** (`a.x`)
    * **成员函数** (`a.f()`)
        * 第一个参数默认是 `self`，名字不一定，可以叫别的
        * 如果不是成员函数，也就是没有 `self` 参数，那么调用的时候会出错
        * `class Test: def add(u, v): return u + v`。当调用的时候如果使用 `a.add(1,2)`, 那么传入了三个参数报错，使用 `Test.add(1,2)` 是可以的
    * **构造函数** (`__init__()`)
        * 通过运行 `self.a` 增加新建对象 `self` 的属性 `a`
        * 不 return 或者值 return None
    * **class variable 类变量**
        * 类变量（class variable）是属于类本身的变量，而不是属于某个特定实例的变量。类变量由所有类的实例共享，即所有实例访问相同的变量。

## Class 高级特性

* **@classmethod, cls**
    * `@classmethod` 是一种装饰器，用于将一个方法定义为类方法。与实例方法不同，类方法不绑定到实例上，而是绑定到类本身。类方法的第一个参数通常命名为 `cls`，表示调用该方法的类。
* **__str__(), __repr__()**
    * `__str__()` 用于 print
        * `def __str__(self): return f"MyClass with value {self.value}"`
    * `__repr__()`，用于开发者调试
        * 如果没有定义 str，会自动使用 repr
        * `def __repr__(self): return f"MyClass({self.value})"`
    * `print(repr(instance))`
* **__le__(), __eq__() 等比较函数**
    * `object.__lt__(self, other)` # x<y
    * `x<y` 调用 `x.__lt__(y)`
    * `object.__le__(self, other)` # x<=y
    * `object.__eq__(self, other)` # x==y
    * `object.__ne__(self, other)` # x!=y
    * `object.__gt__(self, other)` # x>y
    * `object.__ge__(self, other)` # x>=y
* **__add__(), __radd__(), __iadd__() 等算术函数**
    * 对于 `x`
    * `__add__`: `y = x + 1`，x 在左侧调用
    * `__radd__`: `z = -9 + x`，x 在右侧调用
    * `__iadd__`: `x += 100`
    * `__truediv__` ：对应 `/`
    * `__floordiv__` ：对应 `//`
* **__getitem__(), __setitem__()**
    * 通过序号获取一个元素
    * `__getitem__(self, index)`
    * `__setitem__(self, index, value)`
* **一些内省工具**
    * `print(instance.__class__)` 给出 instance 的类
    * `print(MyClass.__name__)` 给出类的名称
    * `print(SubClass.__bases__)` 给出超类的序列
    * `print(instance.__dict__)` 给出对象所有属性的字典
    * `print(dir(MyClass))` 返回对象所有属性和方法的列表
* **一些特殊函数**
    * `__copy__()` 用于 shallow copy
    * `__deepcopy__()` 用于 deep copy
    * `__hash__()` 哈希函数，实现了即 hashable
* **继承的机制（mro 不考）**
    * `class DerivedClassName(BaseClassName1, BaseClassName2, … )`
    * 子类拥有超类所有的属性和方法
    * **overriding** 子类可以重写一个函数，覆盖超类的函数，而父类修改的话子类继承也会修改
    * 子类在继承的时候如果重写 init 的时候必须要先调用父类的 init 函数，否则就没有父类的 init 属性
    * `issubclass(a，b)` 判断 a 是不是 b 的子类
    * `isinstance(a，b)` 判断 a 是不是 b 的对象，a 如果是子类的对象，那也是超类的对象
    * 所有的类都继承了 **object 类**，所有的对象都可以调用 `len()`, `print()`, `id()`, `type()`
    * 一个类继承多个类，按顺序从左向右依次继承。多继承中，如果父类有同名属性或方法，先继承的优先级高于后继承的

## Module 与 Exception

* **Module**
    * **module import 的语法** （`import …`, `from … import …`, 别名）
        * `import module1`
            * `module1.printer('Hello world!')`
        * `from module1 import printer，name2` 只调用了两个函数，别的函数没有调用
            * `printer('Hello world!')`
        * `from module1 import *` 导入所有函数
            * `printer('Hello world!')`
        * `import modulename as name` 原来的 modulename 会被删除
        * `from modulename import attrname as name`
    * **导入顺序**
        * 标准库
        * 第三方库
        * 本地库
    * **__name__与 ’__main__’**
        * 如果是 top level 文件，`__name__` 被设置为 `"__main__"`
        * 如果是被 import 的文件，`__name__` 被设置为模块名
    * Module import 会把 import 的 module 都执行一遍，即使是 `from xxx import xxx` 也会
    * 除非 `reload`，否则多次 import 只 import 一次。
    * `from importlib import reload`
* **Exception**
    * **基本语法：** `try … except … else … finally …`
        * `try:`
            * `# 可能会引发异常的代码`
        * `except SomeException as e:`
            * `# 处理异常的代码`
        * `else:`
            * `# 如果没有引发异常，执行这部分代码`
        * `finally:`
            * `# 无论是否引发异常，都会执行这部分代码`

## Exception 细节与 Assertion

* `finally` 一定会被执行（即使出现一些极端情况比如在循环里面并且前面有 break 或 continue）。
* 如果 try 没有引发 exception，那么 else 会被执行
* 可以用 `raise` 在 except 之后重新引发异常
* 可以用 except 处理多个异常 `except (RuntimeError, TypeError, NameError):`
* 最后一个 except 可以忽略 exception name，处理所有的 except
* **熟悉基本的异常类型**
    * `NameError`：尝试访问未定义的变量时引发。
    * `UnboundLocalError`：在函数中引用一个局部变量，但该变量在赋值前被引用。
    * `IndexError`：尝试访问列表、元组或字符串中不存在的索引。
    * `TypeError`：操作或函数应用于不支持的类型时引发。
    * `ValueError`：操作或函数接收到参数类型正确但值不合适时引发。
    * `KeyError`：尝试访问字典中不存在的键时引发。
    * `ZeroDivisionError`：尝试除以零时引发。
    * `AssertionError`：断言语句失败时引发。
    * `AttributeError`：尝试访问对象中不存在的属性或方法时引发。
* **Assertion**
    * **基本语法与意义**
        * `assert condition, message` 如果 condition 不是 True 会引发 AssertionError，message 可选，提示错误信息
    * **禁用 assert**
        * 通过 `-O` or `-OO` 运行 python
        * 设置系统变量 `set the system variable PYTHONOPTIMIZE to an appropriate value`
        * Python 中，`__debug__` 的默认值是 True，且一旦 Python 解释器运行后就无法更改这个值。`__debug__` 的值取决于 Python 的运行模式：正常模式下值为 True，优化模式下值为 False。
        * assert 语句在正常模式下会启用，即当 `__debug__` 为 True 时执行断言。断言失败时会引发 AssertionError 异常。
    * 执行 `pytest test_samples.py`

## Random 模块

* **random.random()**
    * 返回 [0.0, 1.0) 之间的一个随机浮点数
* **random.randint(a, b)**
    * 返回 a 和 b 之间的一个随机整数，包括 a, b
* **random.randrange(start, stop, step)**
    * 返回一个随机选择的整数从 `range(start, stop, step)`，不包括 stop
    * `random.randrange(stop)` 生成 0 到 stop-1 之间的随机整数
    * `Random.randint(a, b) = random.randrange(a, b+1)`
* **random.uniform(a, b)**
    * 返回 a, b 之间的一个随机浮点数 N，`a <= N <= b` (细节取决于浮点数舍入)
* **random.seed()**
    * 初始化随机数生成器，随机数生成器需要一个数字（seed value）来生成随机数，seed 默认使用当前系统时间。
    * `seed()` 可以定制 seed value，如果 seed 被设置为相同，那么获得的随机数相同（重复执行一个代码获得的值不变，写两遍代码执行一次获得的值是会不同的）
    * seed 必须是 `None, int, float, str, bytes, bytearray`。None 对应默认的 system time，除此以外如果不是整数，会转化为整数。
    * `random.seed(10)` 直接使用
* **random.choice(list)**
    * 从一个非空序列中随机选择一个数 `random.choice(lst)`
* **random.choices(population, weights=None, *, cum_weights=None, k=1)**
    * 返回一个大小为 k 的列表
    * population：要从中选择元素的群体（例如列表、元组等）。
    * weights：一个可选的权重序列，用于指定选择每个元素的概率。如果未指定，所有元素被选择的概率相等。
    * cum_weights：一个可选的累计权重序列，与 weights 参数互斥。
    * k：要选择的元素数量。默认为 1。
    * `*` 表示 `*` 之后只能用关键字参数不能用位置参数
    * 可能会重复，即使 population 中没有重复
* **random.shuffle(list)**
    * 随机打乱一个列表
* **random.sample(population, k)**
    * 从给定的 population 序列或集合中随机选择 k 个唯一的元素，并返回一个包含这些元素的新列表。这些元素是唯一的，并且不会重复（如果 population 里面没有重复）。k 如果大于 population 中元素数量的话会引发 ValueError

## File, Unicode 与编码

* **unicode**
    * Unicode 表中的前 128 个字符与 ASCII 字符完全对应，`A<a`，ASCII 一共有 256 个（包括拓展），一个码不用所以可以看成 255 个
    * Unicode 规定了所有字符的序号，但这个序号不代表编码。
    * **UTF-8 编码：** 字符代码小于 128 的字符表示为一个字节；代码在 128 和 0x7ff (2047) 之间的字符被转换为 2 个字节；代码高于 0x7ff 的字符被转换为 3 或 4 个字节序列。
    * **UTF-16 和 UTF-32：** 分别以固定大小的 2 个字节或 4 个字节格式化文本。
    * **"\xNN"：** 十六进制字节值转义，表示单个字节
        * `hex_escape = "\x48\x65\x6c\x6c\x6f"` # 对应 "Hello"
    * **"\uNNNN"：** Unicode 转义，使用四个十六进制数字编码一个 2 字节（16 位）的字符码点。
        * `unicode_escape = "\u4f60\u597d"` # 对应 "你好"
    * **"\UNNNNNNNN"：** Unicode 转义，使用八个十六进制数字编码一个 4 字节（32 位）的字符码点。
        * `unicode_escape_long = "\U0001f600"`
    * **字节字符串** （bytes 对象）仅支持十六进制转义序列 `"\xNN"` 用于编码文本和其他基于字节的数据
    * 可以在第一行添加注释 `# -*- coding: UTF-8 -*-` 来制定编码方式
    * 可以使用 Unicode 数据库中的字符名来表示特定字符
        * `char_name = "\N{LATIN SMALL LETTER A}"` # 对应字符 'a'

## Byte sequence 语法以及意义

* **一些函数**
    * `ascii()`：返回对象的 ASCII 表示。
    * `bin()`：将整数转换为二进制字符串。
    * `oct()`：将整数转换为八进制字符串。
    * `hex()`：将整数转换为十六进制字符串。
    * `bytes()`：从各种源创建字节对象。
    * `chr()`：返回整数对应的字符。
    * `ord()`：返回字符对应的整数值。
* **btxt = b'hello world'**
    * 字节对象是单个字节的不可变序列。字节字面量的语法与字符串字面量基本相同，只是前面添加了一个 `b`
* **类 bytes([source[, encoding[, errors]]])**
    * 字节字面量中只允许 ASCII 字符。任何超过 127 的二进制值必须使用适当的转义序列输入（`\b`、`\o`、`\x`）。
        * `\x`：表示十六进制转义，如 `\x20` 表示空格。
        * `\b`：表示八进制转义，如 `\141` 表示字符 a。
        * `\o`：表示八进制转义
    * 与字符串字面量一样，字节字面量也可以使用 `r` 前缀来禁用转义序列的处理。
    * source：可以是一个字符串、字节对象或一个可迭代对象。
    * encoding：如果 source 是字符串，必须指定编码。
    * errors：可选的错误处理方案，例如 `'strict'`、`'ignore'`、`'replace'`
* **类方法 fromhex(string)**
    * 这个 bytes 类方法返回一个字节对象，解码给定的字符串对象。字符串每字节必须包含两个十六进制数字，ASCII 空白字符将被忽略。
    * `hex_string = "48656c6c6f..."` `byte_seq = bytes.fromhex(hex_string)`
* **hex([sep[, bytes_per_sep]])**
    * 返回一个字符串对象，其中包含实例中每个字节的两个十六进制数字。
    * `byte_seq.hex()`
* **bytearray 对象是 bytes 对象的可变对应对象**
    * 类 `bytearray([source[, encoding[, errors]]])`
    * `byte_array[0] = ord('H')` 修改可变字节对象
* 在 `.encode()` 和 `.decode()` 中，默认的编码参数是 `"utf-8"`。
* str 和 bytes 具有几乎相同的功能。

## Shell 与 System Modules

* **shell**
    * 绝对路径 `C:\windows\....\a.txt`
    * 相对路径 `.\a\b.txt`
    * 通过 shell 运行 python `filename.py`
        * `filename.py` 应该在当前工作目录
        * 或者使用绝对路径 `python C:\xxxx\....\filename.py`
    * Shell 中，路径名有空格用 `‘’` 包起来处理
    * `python filename.py parameter1 parameter2 parameter3 …`
* **module sys**
    * 提供了对由解释器使用或维护的一些变量的访问，并与解释器强烈交互的功能。
    * **操控 Python 运行时环境的不同部分**
        * `sys.version`：显示当前 Python 解释器版本号的字符串。
        * `sys.argv`：返回传递给 Python 脚本的命令行参数列表。
            * `sys.argv[0]` 包含脚本文件名 xxx.py；`sys.argv[1]` 包含第一个参数。
        * `sys.path`：这是一个环境变量，用于搜索所有 Python 模块的路径。
            * `sys.path[0]`：当前文件的目录。绝对路径：`sys.path[0] + 文件名`
        * `sys.exit`：使脚本退出并返回到 Python 控制台或命令提示符。通常用于在异常生成时安全地退出程序。
        * `sys.maxsize`：返回变量可以取的最大整数值。
        * `sys.stdin`，`sys.stdout` 和 `sys.stderr`：标准数据流
* **Module: standard streams**
    * 标准输入 (stdin)：通常连接到键盘。
    * 标准输出 (stdout) 和 标准错误 (stderr)：通常连接到终端（或窗口）。
    * 使用示例包括 `input()` 获取输入，`print()` 打印输出，以及 `sys.stderr` 写入错误信息。

## Module os 操作系统与 File 对象

* **os 模块**
    * `os.name`：返回当前操作系统的名称。
    * **环境变量：**
        * `os.environ`：获取环境变量的字典。
        * `os.getenv()`：获取指定环境变量的值。
        * `os.putenv()`：设置环境变量的值。
    * **目录操作：**
        * `os.chdir()`：改变当前工作目录。
        * `os.getcwd()`：获取当前工作目录。
        * `os.mkdir()`：创建单级目录。
        * `os.makedirs()`：递归创建多级目录。
    * **文件和目录操作：**
        * `os.remove()`：删除文件。
        * `os.rmdir()`：删除单级空目录。
        * `os.rename(src, dst)`：重命名文件或目录。
        * `os.startfile()`：使用关联应用程序打开文件。
        * `os.walk()`：生成目录树下的所有文件和目录。
    * **路径操作：**
        * `os.path.basename()`：获取文件名。
        * `os.path.dirname()`：获取目录名。
        * `os.path.exists()`：检查路径是否存在。
        * `os.path.isdir()` 和 `os.path.isfile()`：判断路径是目录还是文件。
        * `os.path.join()`：连接多个路径组件。
        * `os.path.split()`：拆分路径成目录和文件名。
* **File 对象**
    * 当程序运行时，其数据存储在随机访问内存（RAM）中。RAM 快速但易失。
    * 非易失性存储介质上的数据（如硬盘）称为文件。
    * 在 Python 中，文件模式可以分为文本模式和二进制模式：
        * **文本模式**
            * 表示使用 `str` 对象。
            * 文件内容按照 Unicode 编码解释。通过传入编码名称给 open 函数，可以强制转换各种类型的 Unicode 文件。
            * 文本模式文件还会执行通用换行符转换：默认情况下，所有换行形式都映射为 `\n`。
            * 文本文件还处理某些 Unicode 编码方案中存储在文件开头的字节顺序标记（BOM）。
        * **二进制模式**
            * 表示使用 `bytes` 对象。
            * 返回原始文件内容，没有编码或解码，也没有换行符转换。

## 文件路径与 Open 函数

* **路径**
    * Mac and Linux: `C:/usr/xxxxx`
    * Windows: `C:\windows\xxxx\`
    * `os.path.join()`：使用当前操作系统的正确斜杠来构建路径字符串。兼容性好。
    * **pathlib（推荐使用）**
        * 使用正斜杠 `/` 即可，Path 对象会将其转换为当前操作系统的正确斜杠。
        * 可以直接在代码中使用 `/` 运算符来添加路径部分。
* **open()以及读取模式**
    * `mf = open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`
    * mode 默认是 read（r），file 文件名必须加 `“”`
    * `r`: read
    * `w`: write 如果不存在会创造，如果存在会先清空原文件，再从头写入
    * `x`: exclusive creation 创建一个文件，如果已经存在会引发异常
    * `b`: binary
    * `+`: read and write
    * `a`: appending 在最后增加，不覆盖原内容
    * 模式可以混合

## File 方法与操作

* **.close()以及 with 语法**
    * `mf.close()`
    * `file.closed`: 如果文件关闭返回 True，否则返回 False
    * `file.mode`: 返回打开文件的模式
    * `file.name`: 返回文件名称
    * 可以多行 `with open('mylog.txt') as infile, open('a.out', 'w') as outfile:`
* **.read(), .readline(), .readlines()**
    * `mf.read()` 读取换行符，从上次读取位置继续读取
    * `mf.readline()` 方法返回一行“字符串”中的所有内容，直到并包括换行符 `\n`。
    * `mf.readlines()`：读取并返回文件中的行的列表。
    * `input()`：当输入 `\n` 时终止，并且 `\n` 会被忽略。
    * `mf.read(n)` 方法：从文件中读取 n 字节。
* **.write(), .writelines()**
    * `mf.write(string)` 把 string 的内容写入 file，返回写入字符的个数，写入的必须是 string
        * 不会添加换行符
    * `f.writelines(lines)` 把一个行的 list 写入文件，必须是 str，不会加换行符
* **.seek(), .flush()**
    * `f.tell()` 返回整数告诉当前文件位置
    * `f.seek(offset, whence)`：用于改变文件对象的位置。
        * `whence` 的值可以是：
            * 0：从文件开头开始测量。默认值
            * 1：使用当前文件位置。
            * 2：使用文件末尾作为参考点。
    * `f.flush()`：刷新文件对象的写缓冲区。将缓冲区中的数据立即写入硬盘
* **混合读写**
    * 先写后读要 `flush()`
    * 先读后写要 `seek()`

## Iterable 与 Iterator

* **iterator 的概念**
    * 迭代器是一个可以迭代的对象，意味着你可以遍历所有的值。
* **iter()与 next()**
    * 一个类，如果实现了 `__iter__()`, `__next__()` 函数，则可以通过 `iter()` 来获得它的迭代器，从而配合 `next()` 函数遍历它。
    * 和这个类对应的 iterable (iterator): 迭代器、广义下标. 可以用 for 来遍历
    * `for x in collection_a`: 给定后，修改 x 不改变 `collection_a` 和迭代顺序
    * `iter() + next()` 获取 `collection_a` 的迭代顺序
    * 在 Python 中，某个对象是否是可迭代的（iterable），取决于它是否是以下两种之一：
        * 物理存储在内存中的序列：比如列表、元组等。
        * 在迭代操作时逐个生成项目的对象：这类对象不将所有项目一次性存储在内存中，而是在需要时动态生成项目。
    * 这两类对象被认为是可迭代的，因为它们支持迭代协议（iteration protocol）：
    * `iter()` 调用会返回一个对象，该对象在接收到 `next()` 调用时会前进，并在完成生成值时引发一个异常。
    * 生成器表达式其值不会一次性存储在内存中，而是在需要时生成。
    * 当使用迭代工具时，Python 文件对象会逐行迭代。
    * 迭代协议的重要性：每一个从左到右扫描对象的 Python 工具都使用迭代协议。
    * 字典本身就是可迭代对象，next 会返回连续的键。
* **可迭代对象（Iterable）**：是指一个支持 `iter()` 调用的对象。
* **迭代器（Iterator）**：是指一个支持 `next()` 调用的对象。它是由可迭代对象调用 `iter()` 方法返回的对象，并且支持 `next()` 方法，能够逐个返回值，直到没有值时引发 `StopIteration` 异常。
* `Range` is iterable 但不是 iterator
* 迭代器的迭代器是自己
* for 循环会调用可迭代对象的 `__iter__()` 方法，以获取迭代器。然后在循环的每次迭代中，for 循环会调用迭代器的 `__next__()` 方法以获取下一个元素。当 `__next__()` 方法引发 `StopIteration` 异常时，for 循环会捕获该异常并退出循环。

## Iterator 实现与 Unpacking

* 系统自定义的 list, tuple 等实现了 `__iter__()`, `__next__()`。自定义的类型，必须自己实现。
* For 遍历过程中，自动调用 `__iter__()`, `__next__()`。
* `next()` 在读取 file 的时候移动一行而不是一个字符
* 两个类型可以互相转换的一个必要条件是它们都是 iterable
* **iterator 的实现：`__iter__()`, `__next__()` 以及 `StopIteration` 异常**
    * `__iter__()`：该方法用于初始化迭代器，可以执行一些初始化操作，但必须返回迭代器对象本身。
    * `__next__()`：该方法用于返回序列中的下一个项目。如果没有更多项目可返回，应引发 `StopIteration` 异常。
* 迭代器不能直接 print 出来，需要用比如 `list()` 转化
* **unpacking: *a, **b**
    * **`*`出现在赋值语句里**
        * `*` 解包对象必须在一个 list 或者 tuple 里面
        * `combined = [*list1, *list2]`
        * `*f` 的 f 经过赋值以后是 list 类型
    * **`*`出现在函数调用里面**
        * `*args` 里面 args 是 tuple 类型
    * **`**`用于解包字典对象**
        * `combined = {**dict1, **dict2}`
    * `all(iterable)` 如果其中所有元素都是 true 返回 True
    * `any(iterable)` 如果其中有一个元素使 True 返回 True

## Match Case 与 Generator

* **Match**
    * 从上往下对比，如果遇到符合的 pattern，就执行该 case 的代码，结束后离开 match
    * `_` : 表示 wildcard, 会 match 任意的情况，可以省略
    * `match command.split(): case [action, obj]:`
    * **结构化匹配**
        * `case ["drop", *objects]`：模式匹配任何以 "drop" 作为第一个元素的序列。剩余的所有元素会被捕获到列表 objects 中
        * `case ["first", (left, right), _, *rest]`：嵌套匹配，占位符匹配。
    * **组合模式** `case ["north"] | ["go", "north"]:`
        * 所有备选模式必须绑定相同的变量。
    * **or 模式和 as 模式**
        * `case ["go", ("north" | "south" | "east" | "west") as direction]`
    * **增加守卫条件**
        * `case ["go", direction] if direction in current_room.exits`
* **Generator**
    * **基本语法**
    * **yield**
        * 当一个函数包含 `yield` 语句时，它会成为一个生成器函数。生成器函数在执行时不会一次性返回一个值，而是会在每次遇到 `yield` 语句时暂停执行，并返回一个值。此时，函数的状态（包括局部变量的值和执行位置）会被保存。当生成器函数被恢复执行时，它会从暂停的地方继续执行，并保留之前的状态。Generator 是自己的 iterator。
        * yield 语句可以有多个
    * **生成器表达式**
        * 生成器表达式的语法和列表推导式非常相似，但它们是用圆括号 `()` 而不是方括号 `[]` 包围的。
        * `even_squares_gen = (x * x for x in range(10) if x % 2 == 0)`
        * 只有一层圆括号可以省略
    * **comprehension 语法**
        * 元组推导，字典推导，集合推导，tuple 没有 comprehension

## 函数高级

* **函数是 callable 的**
    * 可以通过 `greeting.__call__()` 调用函数
    * `print（callable（greeting））`：True，而其它数据类型可能返回 False
    * 一个类要实现 call 方法才是 callable 的
* **默认参数**
    * 函数的默认参数保存在 `funcname.__defaults__` 中
    * 如果默认参数的类型可以被修改，那么默认参数可以变，而且所有的默认参数会一起变，你下次调用的时候默认参数就不是原来的了。None is immutable，只要是 immutable 的，就每次都会 reset。
    * 如果不可以被修改，那么不变。
    * 无论如何，id 不变
* **`__doc__=`, `__name__=`**
    * `__name__`: 函数的名称。
    * `__code__`: 包含编译后的字节码和其他代码对象信息。
    * `__doc__`: 函数的文档字符串。
    * `__dict__`: 包含函数的属性和方法的字典。
* 可以自行增加函数对象的属性

## Property, Scope 与 Decorator

* **property() 和 @property 装饰器用于创建属性**
* **变元作用域：global, nonlocal, del**
    * `nonlocal` 在嵌套函数中使用，允许内层函数中引用外层函数的变量，而不是全局变量。
    * Global, nonlocal, local 对同一个变量只存在一个状态
* **函数的嵌套定义**
    * 内部函数引用外部函数的数据
    * 内部函数被外部函数返回
* **decorator 机制**
    * **函数闭包**：被装饰函数作为参数传入
    * 内嵌函数调用被装饰函数，同时增加新的行为
    * 外部函数返回内嵌函数
    * 不改变被装饰函数代码的情况下，增广其功能
    * 也可以装饰第三方代码，还可以有 `*args`, `**kwargs`，以及有返回值的代码